# 운영체제

#### Q. 운영 체제란 무엇입니까?
운영체제란 하드웨어와 응용 프로그램 사이에서 인터페이스 역할을 하고 시스템의 자원과 동작을 관리하는 시스템 소프트웨어입니다.

#### Q. 운영체제의 역할은 무엇인가요?
운영체제의 역할은 프로세스, 저장장치, 네트워킹, 사용자 계정, 디바이스 드라이버를 관리합니다.

#### Q. 동기와 비동기의 차이는 무엇인가요?
동기(sync)방식은 호출하는 함수의 작업이 종료될 때까지 기다린 뒤 다음 로직을 실행하는 방식입니다. 
비동기(async)방식은 호출하는 함수의 작업 완료 여부와 상관없이 다음 로직이 실행됩니다.

#### Q. Blocking과 non blocking 방식의 차이는 무엇인가요?
Blocking 방식은 호출하는 함수의 작업이 완료되고 return될 때 까지 대기하는 방식입니다.
Non blocking 방식은 호출하는 함수가 작업의 완료와 관계없이 return이 이뤄지는 방식입니다.

#### Q. 프로세스 메모리 영역 구조에 대해서 말해주세요.
프로세스의 메모리 영역은 코드, 데이터, 힙, 스택 영역으로 나뉩니다. 코드 영역은 프로그램을 실행하는데 필요한 코드가 담긴 영역이고 데이터 영역은 전역 변수, 정적 변수가 저장되는 영역입니다. 힙 영역은 사용자가 동적으로 메모리를 할당하고 해제할 수 있는 영역으로 런타임시 크기가 결정됩니다. 스택 영역은 매개 변수, 지역 변수, 리턴 값등이 담기는 영역으로 컴파일시 크기가 결정됩니다. 각 프로세스는 독립된 메모리 영역을 가집니다.

#### Q. 프로세스와 스레드의 차이는 무엇인가요?
프로세스는 실행중인 프로그램으로 운영체제로부터 자원을 할당받아 독립된 메모리영역을 가집니다. 스레드는 프로세스 내부에서 실행되는 작업의 단위로 프로세스의 메모리중 스택 영역을 제외한 나머지를 공유합니다.

#### Q. 멀티 프로세스 vs 멀티 스레드를 비교해주세요.
멀티 프로세스는 작업을 여러 프로세스로 분리한 것으로 각 프로세스는 독립된 메모리 영역을 가지고 있습니다. 멀티 스레드는 프로세스 내부에서 작업을 여러 개의 스레드로 구성하는 것으로 스택 영역을 제외하고 자원을 공유합니다. 
스레드간 Context switching 발생시 stack영역만 변경하면 되기 때문에 오버헤드가 적지만, 프로세스간 Context switching 발생시 캐시, 메모리 매핑 초기화 작업들이 모두 이뤄져 비용이 큽니다. 멀티스레드는 자원을 공유하는 특성으로 인해 동기화 문제가 발생할 수 있고 다른 스레드에게 영향을 줄 수 있습니다. 반면, 멀티프로세스는 독립적인 메모리 영역을 갖기 때문에 하나의 프로세스가 비정상적으로 종료되도 다른 프로세스가 영향을 받지 않습니다. 

#### Q. 시스템 콜은 무엇인가요?
운영체제는 커널 모드와 사용자 모드로 나뉘는데, 시스템 콜은 사용자 모드에서 커널 모드를 사용할 수 있게 해준다. 다시 말해서 응용프로그램에서 커널의 기능을 사용할 수 있게 해준다. 시스템 콜의 유형에는 프로세스 제어, 파일 제어, 디바이스 제어, 정보 관리, 통신등이 있다.

언어에서 시스템 콜을 호출하면 커널 모드로 전환되고, 커널에서 작업이 완료되면 다시 사용자 모드로 전환함.

#### Q. 인터럽트란 무엇인가요?
프로그램이 실행중 입출력 하드웨어 장치나 예외상황 발생으로 작업을 중단하는 것.
내부 인터럽트는 하드웨어 고장, 실행할 수 없는 명령어, 명령어 실행 오류, 권한 문제등으로 발생하며, 외부 인터럽트는 타이머, 입출력 장치에 의해 발생됩니다.

#### Q. 인터럽트의 처리과정은 무엇인가요? 
인터럽트가 발생하면 수행중인 상태를 pcb에 저장하고 pc에 다음에 실행할 주소를 저장한다. 인터럽트 백터를 읽어 인터럽트 서비스 루틴을 실행한다. 

#### Q. context switching이란?
어떤 프로세스가 CPU에서 작업중일 때 다른 프로세스가 CPU를 사용하기 위해 작업중인 내용을 PCB에 저장하고 새로운 프로세스를 CPU로 적재하는 것을 말합니다. 적재된 프로세스는 프로그램 카운터에서 이어서 작업할 주소 복구해 작업을 진행합니다.

#### Q. 프로세스의 상태 변화를 설명하시오
커널에 작업이 등록되면 pcb가 할당되고 프로세스는 new상태로 만들어 집니다. New 상태의 프로세스는 메모리에 적재되면서 ready상태로 전이됩니다. Ready 상태의 프로세스는 cpu 스케쥴링으로 cpu를 할당받게 되면 running 상태로 전이됩니다. Running상태에서 인터럽트가 발생하면 다시 ready상태가 되고, I/O 요청이 발생하면 wating상태로 전이됩니다. IO작업이 종료되면 waiting상태 ready 상태로 전이됩니다. 프로세스의 작업이 완료되면 자원을 반납하고 terminated상태로 전이됩니다.

#### Q. 프로세스 스케쥴링 (long term, short term, medium term)의 차이를 설명하시오
Long term 스케쥴링은 메모리와 디스크 사이에 스케쥴링을 담당합니다. 한정된 메모리에 많은 프로세스가 한번에 올라오는 경우 프로세스는 임시로 디스크에 됩니다. Long term 스케쥴링은 디스크에 있는 프로세스를 메모리에 적재하는 역할을 합니다. 프로세스는 new -> ready상태로 전이시킵니다.

Medium term 스케쥴링은 메모리에 올라간 프로세스 수를 조절하기위해 메모리 상의 프로세스를 통째로 swap device로 쫒아내는 swap out을 합니다. 프로세스에게 메모리를 deallocate하며 프로세스의 상태를 suspended로 전이시킵니다.

Short term 스케쥴링은 ready상태의 프로세스에게 cpu를 할당하는 작업을 합니다. 

#### Q. CPU 스케쥴링이란?
Ready queue에 들어있는 프로세스중 어떤 프로세스에게 cpu를 할당할지 결정하는 작업을 말합니다. CPU 스케쥴링 방식에는 선점, 비선점 방식 있습니다. 선점 방식은 cpu burst가 끝날 때 까지 context switching이 발생하지 않고 대기하는 것을 말하고, 비선점 방식은 cpu burst가 끝나지 않더라도 context switching이 발생하는 방식을 말합니다. 

#### Q. CPU 스케쥴링은 언제 발생하는가?
인터럽트 발생으로 running -> ready상태로 전이될 때,
I/O작업 및 다른 이벤트 발생으로 running -> waiting 상태로 전이될 때,
I/O 또는 다른 이벤트 작업 완료로 waiting -> ready 상태로 전이될 때,
프로세스가 종료 될 때 발생합니다.

#### Q. CPU 스케쥴링 기법들을 설명하시오
FCFS : 먼저 온 순서대로 스케쥴링하는 비선점 방식 
RR : 일정 time slice를 기준으로 ready queue의 프로세스를 돌아가며 실행하는 선점 방식
PR : 우선 순위를 결정하여 스케쥴링하는 방식. 선점/비선점 둘 다 가능
SJF : cpu burst가 짧은 작업을 먼저 처리하는 비선점 방식
SRT : 남은 작업 시간이 짧은 프로세스를 먼저 처리하는 선점 방식
HRRN : SJF방식에 시간이 지남에 따라 우선 순위를 높여 처리하는 방식
MLQ : ready queue를 여러 개로 구성하고 우선순위를 부여하는 방식
MFQ : ready queue를 여러 개로 구성하고 우선순위를 부여하며, 최초 배정받은 queue에서도 이동가능한 방식

#### Q. Starvation 현상은 무엇인가요?
낮은 우선순위로 프로세스가 실행되지 못하는 현상 

#### Q. Critical section이란?
어떤 공유자원에 대해 동시에 접근하는 작업이 실행되는 영역. Critical section 문제를 해결하기 위해서는 어떤 프로세스가 critical section에서 작업중이라면 다른 프로세스는 접근하지 못하도록 하는 mutual exclusion, critical section에서 작업중인 프로세스가 없다면 대기중인 프로세스는 critical section에 진입하도록 하는 progress, 대기하는 프로세스에 대하여 무한정 대기하는게 아닌 제한된 대기하는 bounded wait조건을 만족해야 합니다.

#### Q. 프로세스 동기화란?
공유 자원에 대하여 동시에 사용하지 못하도록 실행을 제어하는 기법

#### Q. Mutual exclusion이란?
특정 공유 자원을 한 순간에 한 개의 프로세스만 사용할 수 있을 때, 어떤 프로세스가 공유 자원에 접근하는 동안 다른 프로세스가 해당 자원에 접근할 수 없게 하는 것

#### Q. Spin lock과 semaphore를 설명하시오

#### Q. 뮤텍스와 세마포어의 차이는?
	`
#### Q. eventcount/sequencer이란? 동작 원리는?

#### Q. 모니터란? 동작 원리는?

#### Q. 데드락이란? 
데드락이란 발생 가능성이 없는 이벤트를 기다리는 상태를 말합니다.

#### Q. 데드락의 발생 조건?
데드락은 4가지의 조건이 모두 충족되어야 발생합니다.
첫번째, exclusive한 자원에 대해 여러 프로세스가 동시에 사용하려는 경우 mutual exclusion
두번째, 비선점의 특성을 지닌 자원 no preemption
세번째, 자원을 소유하고 있으면서 다른 자원을 요청하는 hold and wait
네번째, 프로세스간 자원을 요청하는 형태가 원을 만드는 circular wait

#### Q. 데드락을 해결 하는 방법은?
데드락의 해결 방법에는 예방, 회피, 탐지 3가지가 있습니다.
Prevention
deadlock prevention은 데드락이 성립하는 4가지 요건중 하나를 제거하므로서 데드락을 예방합니다.
첫 번째로 모든 자원 공유를 허용할 수 있습니다. 하지만 동시에 자원을 사용하므로서 동기화 문제가 발생합니다. 
두 번째는 모든 자원에 대해 선점을 허용할 수 있습니다. 프로세스가 할당 받을 수 없는 자원을 요청한 경우 기존에 가지고 있던 자원을 반납하고 작업을 취소해야합니다. 이후 처음부터 또는 checkpoint부터 시작할 순 있지만 심각한 자원 낭비가 발생합니다. 
세 번째는 필요한 자원을 한번에 모두 할당하는 방법입니다. 이 방식은 독점으로 인해 필요하지 않는 순간에도 자원을 소유해 자원 낭비가 발생합니다.
네 번째는 circular wait조건을 제거하는 것입니다. 자원들에게 순서를 부여하여 프로세스는 순서의 증가 방향으로만 자원 요청을 가능하게 합니다. 이렇게 하면 순서에 맞지않는 자원을 할당받을 수 없어 데드락이 발생하지 않습니다. 하지만 자원이 있음에도 순서로 인해 작업이 진행되지 않는 상황이 발생할 수 있습니다.

prevention은 자원의 효율성을 떨어트리고 비용이 많이드는 방법입니다. 또한, 다른 문제를 야기할 수 있습니다.

Avoidance
deadlock avoidance는 시스템의 상태를 계속 감시하면서 deadlock 상태가 될 가능성이 있는 자원 할당을 보류합니다. 시스템을 항상 safe state로 유지하면서 데드락을 회피합니다.
safe state는 모든 프로세스가 정상적으로 종료할 수 있는 상태를 말하며 safe sequence가 존재합니다. safe sequence를 통해 deadlock상태가 되지않음을 보장할 수 있습니다.
unsafe state는 deadlock이 발생할 가능성이 존재하는 상태입니다. 반드시 데드락이 발생한다는 의미는 아닙니다.
deadlock avoidance는 몇 가지의 가정을 갖습니다. 
프로세스 수, 자원의 종류와 수가 고정되어있어야합니다. 또, 프로세스가 요구하는 자원 및 최대 수량을 알고 있어야합니다. 프로세스는 자원을 사용후에 반드시 반납해야합니다. 다소 현실적이지 않은 가정입니다.
deadlock avoidance중에 은행원 알고리즘이라고 불리는 다익스트라 알고리즘이 있습니다. 
전체 필요한 자원, 현재 가진 자원, 추가적으로 필요한 자원 수를 통해 자원을 줬다고 가정합니다. 순차적으로 시나리오를 구성해 작업이 모두 완료될 수 있는 상태가 존재하면 safe state라고 할 수 있습니다. safe state가 존재하면 자원을 빌려주고 아니라면 자원 요청을 거절합니다.
deadlock avoidance는 항상 시스템을 감시해야하는 오버헤드가 있습니다. 또 unsafe state라고해서 반드시 데드락이 발생하지는 않는데, safe state상태여야만 자원을 빌려주기 때문에 자원의 활용도가 떨어집니다. 그리고 deadlock avoidance를 하기위한 초기 가정이 현실적이지 않은 문제가 있습니다.

Detection
deadlock detection은 deadlock 방지를 위한 사전작업을 하지 않습니다. 따라서 deadlock이 발생할 수 있습니다. 주기적으로 deadlock을 확인하면서 데드락이 감지된 경우 recovery가 필요합니다. avoidance와 detection의 차이점은 avoidance는 미래에 발생할 최악의 경우를 고려해서 deadlock이 발생하지 않게 해준다면 detection은 현재상태만을 고려해서 deadlock 발생시 recovery과정이 필요합니다.
deadlock 검출에는 RAG(resoure allocation graph)를 사용합니다. 주어진 rag에서 edge를 하나씩 지워나가면서 deadlock을 탐지하는데, 모든 edge가 제거되면 데드락에 빠진 프로세스는 없게 됩니다. 반면 지울 수 없는 edge가 존재하면 하나이상의 프로세스가 deadlock상태라고 할 수 있습니다. 과정은 다음과 같습니다. 필요한 자원을 모두 할당 받을 수 있는 unblocked process에 연결된 모든 edge를 제거합니다. 더 이상 unblocked process가 없을 때 까지 이 작업을 반복합니다. 최종 그래프에서 남아 있는 edge를 확인하고 현재 deadlock 상태를 판단합니다.
이 방식을 graph reduction이라고 하는데 검사에 따른 비용이 발생하며 node의 수가 증가함에 따라 더 복잡해집니다.

Deadlock Recovery는 deadlock을 검출한 뒤 해결하는 과정입니다. 데드락에 빠진 프로세스중 종료하거나 자원을 소유한 프로세스를 종료하여 데드락을 해소할 수 있습니다. 그렇다면 어떤 프로세스를 종료시킬지가 정해져야하는데 우선순위, 총 수행시간, 남은 수행시간등 cost를 고려하여 모델을 선정합니다.

#### Q. 메모리의 계층 구조는?

#### Q. address binding이란?

#### Q. swapping 이란?
			
#### Q. Fragmentation에 대해 설명하시오

#### Q. FPM과 VPM에 대해 설명하시오
		
#### Q. VPM의 배치 전략은?

#### Q. VPM의 external fragmentation을 해소하는 방법은?

#### Q. 가상 메모리란?

#### Q. 가상 메모리의 address mapping과 과정을 설명하시오

#### Q. paging 시스템이란?

#### Q. paging 시스템의 address mapping 방식과 장단점을 나열하시오

#### Q. paging 시스템의 메모리 관리 방법은?

#### Q. paging 시스템의 공유자원/보안 문제에 대해 설명하시오
 
#### Q. segment 시스템이란?

#### Q. segment 시스템의 address mapping 방식과 장단점을 나열하시오

#### Q. segmentation 시스템의 메모리 관리 방법은?

#### Q. hybrid paging/segmentation에 대해서 설명하시오

#### Q. page fault란?

#### Q. Page reference string이란?

#### Q. Bit vector는 무엇인가요?

#### Q. 가상메모리를 관리하기위한 software적인 방법은?

#### Q. Page size는 큰게 좋나요 작은게 좋나요?
	
#### Q. Locality는 무엇인가요?

#### Q. Page 메모리 교체 알고리즘에 대해서 설명해주세요.

#### Q. Variable allocation 교체 기법에서는 어떻게 윈도우 사이즈를 결정하나요?

