# 운영체제

#### Q. 운영 체제란 무엇입니까?
운영체제란 하드웨어와 응용 프로그램 사이에서 인터페이스 역할을 하고 시스템의 자원과 동작을 관리하는 시스템 소프트웨어입니다.

#### Q. 운영체제의 역할은 무엇인가요?
운영체제의 역할은 프로세스, 저장장치, 네트워킹, 사용자 계정, 디바이스 드라이버를 관리합니다.

#### Q. 동기와 비동기의 차이는 무엇인가요?
동기(sync)방식은 호출하는 함수의 작업이 종료될 때까지 기다린 뒤 다음 로직을 실행하는 방식입니다. 여러 요청을 동시에 처리할 순 없지만 설계가 직관적이고 간단합니다. 비동기(async)방식은 호출하는 함수의 작업 완료 여부와 상관없이 다음 로직이 실행됩니다. 여러 요청을 동시에 처리할 수 있지만 설계가 비교적 복잡합니다.

#### Q. Blocking과 Non-Blocking 방식의 차이는 무엇인가요?
blocking은 호출된 함수가 자신의 작업이 모두 끝낼 때까지 제어권을 가지고 있어 호출한 함수가 대기하도록 만듭니다. non-blocking은 호출된 함수가 바로 return하며 호출한 함수에게 제어권을 줍니다.
Non-blocking sync은 함수가 호출되고 바로 반환합니다. 하지만 요청한 함수의 작업 완료 여부를 호출한 메서드에서 계속 확인한다. blocking async는 함수가 호출되면 callback을 기다리며 대기합니다. 이런 상황이 발생하는 경우로 spring jdbc는 blocking방식으로 동작하는데 async방식과 섞이게 되면 blocking async방식으로 동작하게 됩니다.

#### Q. 프로세스 메모리 영역 구조에 대해서 말해주세요.
프로세스의 메모리 영역은 코드, 데이터, 힙, 스택 영역으로 나뉩니다. 코드 영역은 프로그램을 실행하는데 필요한 코드가 담긴 영역이고 데이터 영역은 전역 변수, 정적 변수가 저장되는 영역입니다. 힙 영역은 사용자가 동적으로 메모리를 할당하고 해제할 수 있는 영역으로 런타임시 크기가 결정됩니다. 힙 영역의 메모리는 낮은 주소에서 높은 주소 방향으로 할당됩니다. 스택 영역은 매개 변수, 지역 변수, 리턴 값등이 담기는 영역으로 컴파일시 크기가 결정됩니다. 스택 영역의 메모리는 높은 주소에서 낮은 주소로 할당됩니다. 각 프로세스는 독립된 메모리 영역을 가집니다.

#### Q. 프로세스와 스레드의 차이는 무엇인가요?
프로세스는 실행중인 프로그램으로 운영체제로부터 자원을 할당받아 독립된 메모리영역을 가집니다. 스레드는 프로세스 내부에서 실행되는 작업의 단위로서 프로세스의 메모리중 스택 영역을 제외한 나머지를 공유합니다.

#### Q. 멀티 프로세스 vs 멀티 스레드를 비교해주세요.
멀티 프로세스는 작업을 여러 프로세스로 분리한 것으로 각 프로세스는 독립된 메모리 영역을 가지고 있습니다. 멀티 스레드는 프로세스 내부에서 작업을 여러 개의 스레드로 처리하는 것으로 스택 영역을 제외하고 자원을 공유합니다. 스레드간 Context switching 발생시 stack영역만 변경하면 되기 때문에 상대적으로 오버헤드가 적지만, 프로세스간 Context switching 발생시 캐시, 메모리 매핑 초기화 작업들이 모두 이뤄져 상대적으로 오버헤드가 큽니다. 멀티스레드는 자원을 공유하는 특성으로 인해 동기화 문제가 발생할 수 있고 다른 스레드에게 영향을 줄 수 있습니다. 반면, 멀티프로세스는 독립적인 메모리 영역을 갖기 때문에 하나의 프로세스가 비정상적으로 종료되도 다른 프로세스가 영향을 받지 않습니다. 

#### Q. 운영체제에서 커널(kernel)은 무엇인가요?
커널(kernel)은 컴퓨터의 운영 체제의 핵심이 되는 컴퓨터 프로그램의 하나로, 시스템의 모든 것을 통제합니다. 커널은 메모리 관리, 프로세스 관리, 장치 드라이버 관리, 시스템 호출 및 보안을 담당합니다. 메모리 관리는 메모리가 어디에서 무엇을 저장하는 데 얼마나 사용되는지를 추적합니다. 프로세스 관리는 어느 프로세스가 CPU를 언제 얼마나 오랫동안 사용할지를 결정합니다. 장치 드라이버 관리는  하드웨어와 프로세스 사이에서 중재자/인터프리터의 역할을 수행합니다. 시스템 호출 및 보안은 프로세스의 서비스 요청을 수신합니다.   

#### Q. 시스템 콜은 무엇인가요?
운영체제는 커널 모드와 사용자 모드로 나뉘는데, 시스템 콜은 사용자 모드에서 커널 모드를 사용할 수 있게 해줍니다. 다시 말해서 응용프로그램에서 커널의 기능을 사용할 수 있게 해준다. 시스템 콜의 유형에는 프로세스 제어, 파일 제어, 디바이스 제어, 정보 관리, 통신등이 있습니다. 프로그래밍 언어에서 시스템 콜을 호출하면 커널 모드로 전환되고, 커널에서 작업이 완료되면 다시 사용자 모드로 전환됩니다.

#### Q. 인터럽트란 무엇인가요?

#### Q. 인터럽트의 처리과정은 무엇인가요? 

#### Q. Context Switching이란?
어떤 프로세스가 CPU에서 작업중일 때 다른 프로세스가 CPU를 사용하기 위해 작업중인 내용을 PCB에 저장하고 새로운 프로세스를 CPU로 적재하는 것을 말합니다. 적재된 프로세스는 프로그램 카운터에서 이어서 작업할 주소를 복구하여 작업을 진행합니다.

#### Q. 프로세스의 상태 변화를 설명하시오
커널에 작업이 등록되면 pcb가 할당되고 프로세스는 new상태로 만들어 집니다. New 상태의 프로세스는 메모리에 적재되면서 ready상태로 전이됩니다. Ready 상태의 프로세스는 cpu 스케쥴링으로 cpu를 할당받게 되면 running 상태로 전이됩니다. Running상태에서 인터럽트가 발생하면 다시 ready상태가 되고, I/O 요청이나 기타 이벤트 발생하면 wating상태로 전이됩니다. IO/기타 이벤트 작업이 종료되면 waiting상태 ready 상태로 전이됩니다. 프로세스의 작업이 완료되면 자원을 반납하고 terminated상태로 전이됩니다. 스케쥴링에 따라 ready, waiting 상태의 프로세스는 swap device로 swap out될 수 있습니다. 이런 경우 suspended ready, suspended waiting상태로 전이됩니다. 

#### Q. 프로세스 스케쥴링 (long term, short term, medium term)의 차이를 설명하시오
Long term 스케쥴링은 메모리와 디스크 사이에 스케쥴링을 담당합니다. 한정된 메모리에 많은 프로세스가 한번에 올라오는 경우 프로세스는 임시로 디스크에 저장됩니다. Long term 스케쥴링은 디스크에 있는 프로세스를 메모리에 적재하는 역할을 합니다. 프로세스는 new -> ready상태로 전이시킵니다.

Medium term 스케쥴링은 메모리에 올라간 프로세스 수를 조절하기위해 메모리 상의 프로세스를 통째로 swap device로 쫒아내는 swap out을 합니다. 프로세스에게 메모리를 deallocate하며 프로세스의 상태를 suspended로 전이시킵니다. swap out되는 프로세스는 ready, waiting상태이며 ready상태보단 waiting상태가 당장 cpu를 할당받을 가능성이 낮기 때문에 우선적으로 swap out됩니다. 

Short term 스케쥴링은 ready상태의 프로세스에게 cpu를 할당하는 작업을 합니다. 

#### Q. CPU 스케쥴링이란?
Ready queue에 들어있는 프로세스중 어떤 프로세스에게 cpu를 할당할지 결정하는 작업을 말합니다. CPU 스케쥴링 방식에는 선점, 비선점 방식 있습니다. 비선점 방식은 cpu burst가 끝날 때 까지 context switching이 발생하지 않고 대기하는 것을 말하고, 선점 방식은 cpu burst가 끝나지 않더라도 context switching이 발생하는 방식을 말합니다. cpu 스케쥴링의 대상이되어 cpu를 할당 받게되면 프로세스 상태가 ready -> new 상태로 전이됩니다.

#### Q. CPU 스케쥴링은 언제 발생하는가?
인터럽트 발생으로 running -> ready상태로 전이될 때,
I/O작업 및 다른 이벤트 발생으로 running -> waiting 상태로 전이될 때, 
I/O 또는 다른 이벤트 작업 완료로 waiting -> ready 상태로 전이될 때,
프로세스가 종료 될 때 발생합니다.

#### Q. CPU 스케쥴링 기법들을 설명하시오
FCFS(first come first served) : 먼저온 순서대로 처리하는 방식으로 구현이 간단합니다. 비선점형으로서 CPU burst가 완료될 때까지 CPU를 반환하지 않습니다. 소요시간이 긴 프로세스가 먼저 도착하면 짧은 프로세스는 대기시간이 길어지는 convoy effect가 발생합니다.   

Round Robin : 일정 time slice를 기준으로 ready queue의 프로세스를 돌아가며 실행하는 선점 방식입니다. 시간이 경과하면 ready queue의 끝에 추가되고 다음 프로세스가 CPU를 할당받습니다. - time slice가 길수록 FCFS방식과 유사하고 짧을수록 모든 프로세스가 동시에 작업하는 것처럼 보이지만 context switching에 대한 오버헤드가 커집니다.    

Priority Scheduling : - 우선순위가 가장 높은 프로세스에게 CPU를 할당하는 방식입니다. 선점형과 비선점형 둘 다 가능하며 비선점형은 더 높은 우선순위의 프로세스가 오면 ready queue의 head에 추가됩니다. 우선 순위가 낮은 프로세스는 차례가 오지 않는 starvation 문제가 발생할 수 있는데 aging기법으로 시간이 지남에 따라 우선순위를 높여주는 방식을 적용할 수 있습니다.  

SJF(shortest job first) : - CPU burst time이 짧은 프로세스에게 CPU를 할당합니다. 비선점형으로 더 짧은 CPU burst time을 갖는 프로세스가 오면 ready queue의 head에 추가됩니다. 시스템의 프로세스를 최소화하여 스케쥴링의 부하가 감소하고 메모리를 절약해 시스템 효율을 높이지만 CPU burst time이 길면 starvation문제가 존재하고 CPU burst time을 예측해야한다는 어려움이 있습니다.

SRT(shortest remaining time) : 잔여 실행시간이 짧은 프로세스에게 CPU를 할당합니다. 선점형으로 잔여 실행시간이 더 짧은 프로세스가 오면 CPU를 반납합니다. 주어진 집합에대해 최소 평균 대기시간을 제공하지만 여전히 starvation문제와 잔여 실행 시간을 예측해야한다는 문제점이 있습니다.

HRRN(highest respone ratio next) : SJF의 단점인 긴 작업과 짧은 작업의 불평등을 보완한 방식으로 대기 시간이 길어질수록 우선 순위가 높아집니다. starvation을 방지할 수 있지만 cpu burst time을 예측해야하는 문제가 있습니다.

MLQ(multi level queue): ready queue를 여러개로 분리하고 큐 사이에도 우선순위를 부여하는 방식입니다. 각 queue는 우선순위를 가지며 프로세스는 최초에 배정된 queue를 벗어나지 못합니다. 선점형 스케쥴링 방식으로 여러개의 queue를 관리해야하는 overhead와 우선 순위에 따른 starvation 문제가 존재합니다.

MFQ(multi level feedback queue) :  ready queue를 여러개로 분리하고 큐 사이에도 우선순위를 부여하는 방식으로 프로세스는 최초에 배정된 queue를 벗어날 수 있습니다. IO bounded process는 높은 우선순위를 가지고 cpu bounded process는 낮은 우선순위를 가집니다. 우선 순위가 높은 큐일수록 짧은 time slice를 주고 time slice내에 작업이 끝나면 한단계 낮은 큐로 내려 보냅니다. 반대로 어떤 큐에서 일정시간내에 작업이 실행되지 못하면 한단계 높은 큐로 프로세스를 이동시킵니다. 이를 통해 starvation문제를 해결할 수 있습니다. 

#### Q. Starvation 현상은 무엇인가요?
낮은 우선순위로 프로세스가 실행되지 못하는 현상 

#### Q. Critical section이란?
어떤 공유자원에 대해 동시에 접근하는 작업이 실행되는 영역. Critical section 문제를 해결하기 위해서는 어떤 프로세스가 critical section에서 작업중이라면 다른 프로세스는 접근하지 못하도록 하는 mutual exclusion, critical section에서 작업중인 프로세스가 없다면 대기중인 프로세스는 critical section에 진입하도록 하는 progress, 대기하는 프로세스에 대하여 무한정 대기하는게 아닌 제한된 대기하는 bounded wait조건을 만족해야 합니다.

#### Q. 프로세스 동기화란?
공유 자원에 대하여 동시에 사용하지 못하도록 실행을 제어하는 기법

#### Q. Mutual exclusion이란?
특정 공유 자원을 한 순간에 한 개의 프로세스만 사용할 수 있을 때, 어떤 프로세스가 공유 자원에 접근하는 동안 다른 프로세스가 해당 자원에 접근할 수 없게 하는 것

#### Q. Spin lock과 semaphore를 설명하시오

#### Q. 뮤텍스와 세마포어의 차이는?
	`
#### Q. eventcount/sequencer이란? 동작 원리는?

#### Q. 모니터란? 동작 원리는?

#### Q. 데드락이란? 
데드락이란 발생 가능성이 없는 이벤트를 기다리는 상태를 말합니다.

#### Q. 데드락의 발생 조건?
데드락은 4가지의 조건이 모두 충족되어야 발생합니다.
첫번째, exclusive한 자원에 대해 여러 프로세스가 동시에 사용하려는 경우 mutual exclusion
두번째, 비선점의 특성을 지닌 자원 no preemption
세번째, 자원을 소유하고 있으면서 다른 자원을 요청하는 hold and wait
네번째, 프로세스간 자원을 요청하는 형태가 원을 만드는 circular wait

#### Q. 데드락을 해결 하는 방법은?
데드락의 해결 방법에는 예방, 회피, 탐지 3가지가 있습니다.
Prevention
deadlock prevention은 데드락이 성립하는 4가지 요건중 하나를 제거하므로서 데드락을 예방합니다.
첫 번째로 모든 자원 공유를 허용할 수 있습니다. 하지만 동시에 자원을 사용하므로서 동기화 문제가 발생합니다. 
두 번째는 모든 자원에 대해 선점을 허용할 수 있습니다. 프로세스가 할당 받을 수 없는 자원을 요청한 경우 기존에 가지고 있던 자원을 반납하고 작업을 취소해야합니다. 이후 처음부터 또는 checkpoint부터 시작할 순 있지만 심각한 자원 낭비가 발생합니다. 
세 번째는 필요한 자원을 한번에 모두 할당하는 방법입니다. 이 방식은 독점으로 인해 필요하지 않는 순간에도 자원을 소유해 자원 낭비가 발생합니다.
네 번째는 circular wait조건을 제거하는 것입니다. 자원들에게 순서를 부여하여 프로세스는 순서의 증가 방향으로만 자원 요청을 가능하게 합니다. 이렇게 하면 순서에 맞지않는 자원을 할당받을 수 없어 데드락이 발생하지 않습니다. 하지만 자원이 있음에도 순서로 인해 작업이 진행되지 않는 상황이 발생할 수 있습니다.

prevention은 자원의 효율성을 떨어트리고 비용이 많이드는 방법입니다. 또한, 다른 문제를 야기할 수 있습니다.

Avoidance
deadlock avoidance는 시스템의 상태를 계속 감시하면서 deadlock 상태가 될 가능성이 있는 자원 할당을 보류합니다. 시스템을 항상 safe state로 유지하면서 데드락을 회피합니다.
safe state는 모든 프로세스가 정상적으로 종료할 수 있는 상태를 말하며 safe sequence가 존재합니다. safe sequence를 통해 deadlock상태가 되지않음을 보장할 수 있습니다.
unsafe state는 deadlock이 발생할 가능성이 존재하는 상태입니다. 반드시 데드락이 발생한다는 의미는 아닙니다.
deadlock avoidance는 몇 가지의 가정을 갖습니다. 
프로세스 수, 자원의 종류와 수가 고정되어있어야합니다. 또, 프로세스가 요구하는 자원 및 최대 수량을 알고 있어야합니다. 프로세스는 자원을 사용후에 반드시 반납해야합니다. 다소 현실적이지 않은 가정입니다.
deadlock avoidance중에 은행원 알고리즘이라고 불리는 다익스트라 알고리즘이 있습니다. 
전체 필요한 자원, 현재 가진 자원, 추가적으로 필요한 자원 수를 통해 자원을 줬다고 가정합니다. 순차적으로 시나리오를 구성해 작업이 모두 완료될 수 있는 상태가 존재하면 safe state라고 할 수 있습니다. safe state가 존재하면 자원을 빌려주고 아니라면 자원 요청을 거절합니다.
deadlock avoidance는 항상 시스템을 감시해야하는 오버헤드가 있습니다. 또 unsafe state라고해서 반드시 데드락이 발생하지는 않는데, safe state상태여야만 자원을 빌려주기 때문에 자원의 활용도가 떨어집니다. 그리고 deadlock avoidance를 하기위한 초기 가정이 현실적이지 않은 문제가 있습니다.

Detection
deadlock detection은 deadlock 방지를 위한 사전작업을 하지 않습니다. 따라서 deadlock이 발생할 수 있습니다. 주기적으로 deadlock을 확인하면서 데드락이 감지된 경우 recovery가 필요합니다. avoidance와 detection의 차이점은 avoidance는 미래에 발생할 최악의 경우를 고려해서 deadlock이 발생하지 않게 해준다면 detection은 현재상태만을 고려해서 deadlock 발생시 recovery과정이 필요합니다.
deadlock 검출에는 RAG(resoure allocation graph)를 사용합니다. 주어진 rag에서 edge를 하나씩 지워나가면서 deadlock을 탐지하는데, 모든 edge가 제거되면 데드락에 빠진 프로세스는 없게 됩니다. 반면 지울 수 없는 edge가 존재하면 하나이상의 프로세스가 deadlock상태라고 할 수 있습니다. 과정은 다음과 같습니다. 필요한 자원을 모두 할당 받을 수 있는 unblocked process에 연결된 모든 edge를 제거합니다. 더 이상 unblocked process가 없을 때 까지 이 작업을 반복합니다. 최종 그래프에서 남아 있는 edge를 확인하고 현재 deadlock 상태를 판단합니다.
이 방식을 graph reduction이라고 하는데 검사에 따른 비용이 발생하며 node의 수가 증가함에 따라 더 복잡해집니다.

Deadlock Recovery는 deadlock을 검출한 뒤 해결하는 과정입니다. 데드락에 빠진 프로세스중 종료하거나 자원을 소유한 프로세스를 종료하여 데드락을 해소할 수 있습니다. 그렇다면 어떤 프로세스를 종료시킬지가 정해져야하는데 우선순위, 총 수행시간, 남은 수행시간등 cost를 고려하여 모델을 선정합니다.

#### Q. 메모리의 계층 구조는?

#### Q. address binding이란?

#### Q. swapping 이란?
			
#### Q. Fragmentation에 대해 설명하시오

#### Q. FPM과 VPM에 대해 설명하시오
		
#### Q. VPM의 배치 전략은?

#### Q. VPM의 external fragmentation을 해소하는 방법은?

#### Q. 가상 메모리란?

#### Q. 가상 메모리의 address mapping과 과정을 설명하시오

#### Q. paging 시스템이란?

#### Q. paging 시스템의 address mapping 방식과 장단점을 나열하시오

#### Q. paging 시스템의 메모리 관리 방법은?

#### Q. paging 시스템의 공유자원/보안 문제에 대해 설명하시오
 
#### Q. segment 시스템이란?

#### Q. segment 시스템의 address mapping 방식과 장단점을 나열하시오

#### Q. segmentation 시스템의 메모리 관리 방법은?

#### Q. hybrid paging/segmentation에 대해서 설명하시오

#### Q. page fault란?

#### Q. Page reference string이란?

#### Q. Bit vector는 무엇인가요?

#### Q. 가상메모리를 관리하기위한 software적인 방법은?

#### Q. Page size는 큰게 좋나요 작은게 좋나요?
	
#### Q. Locality는 무엇인가요?

#### Q. Page 메모리 교체 알고리즘에 대해서 설명해주세요.

#### Q. Variable allocation 교체 기법에서는 어떻게 윈도우 사이즈를 결정하나요?

