# Backend 개발 지식

<details>
    <summary style="font-size : 20px;"><strong> Q. ORM/JPA는 무엇인가요?</strong></summary></br>
    
ORM은 object relational mapping의 약자로 객체와 데이터베이스간 데이터를 매핑해주는 기법입니다.

JPA는 자바 ORM에 대한 API 표준 명세입니다. 대표적인 구현체로 hibernate가 있습니다.
</details></br>
    
<details>
    <summary style="font-size : 20px;"><strong> Q. JPA는 장단점이 무엇인가요?</strong></summary></br>
   
**장점**  
**생산성**  
JPA를 사용하면 자바 컬렉션에 객체를 저장하듯이 JPA에 저장할 객체를 전달하면됩니다. SQL을 작성하고 JDBC API를 사용하는 반복적인 일을 JPA에서 대신해준다. 

**유지보수**   
유지 보수 측면에서는 SQL의존적인 개발은 엔티티 컬럼이 변경되는 상황에서 연관된 모든 SQL문을 수정해야하고 결과를 매핑하기 위한 JDBC API도 변경해야합니다. JPA는 이러한 과정을 대신 처리해줍니다.

**패러다임 불일치 문제 해결**    
데이터 베이스는 데이터 중심으로 구조화되어있어 객체 지향 언어와 패러다임 불일치 문제가 발생합니다. JPA는 데이터 베이스에 맞춰 데이터를 저장하기위해
객체를 매핑하는 과정에서 드는 비용을 없애 좀 더 객체지향적인 개발이 가능하게 합니다.

**DB벤더 교체 용이성**   
SQL의존적인 개발은 DB벤더마다 문법이 다르기 때문에 다른 데이터베이스로 변경하는 작업이 쉽지않습니다. JPA는 데이터베이스와 애플리케이션 사이에서 추상화 계층을 제공하므로 변경 작업이 비교적 간편합니다,

**단점**
JPA의 단점은 복잡한 통계 쿼리를 처리하기 어려운 특성이있고, 실제로 어떤 쿼리가 실행될지 알 수 없으며, N+1문제, 등이 발생할 수 있습니다.
</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. JPA에서 N+1문제는 무엇인가요?</strong></summary></br>
    
N+1문제는 다른 테이블을 Join해서 가져오지않고 일일히 select문을 통해 join된 결과를 만들어내는 문제입니다. 

**원인**   
N+1문제는 1:N관계에서 JPQL을 사용할 때 발생할 수 있습니다.

먼저, JPQL의 동작 과정은 아래와 같습니다.
1. JPQL을 호출하면 데이터베이스에 우선적으로 조회합니다.
2. 조회한 값을 영속성 컨텍스트에 저장합니다.
3. 영속성 컨텍스트에 조회할 때 이미 존재하는 데이터가 있다면 데이터를 버립니다.
JPQL은 이러한 동작 과정에서 연관 관계를 고려하지 않고 SQL문을 생성합니다. 이후 JPA에서 글로벌 fetch전략을 적용시킵니다. 
Eager모드가 적용되어 있다면 JPA에서는 즉시 연관 관계를 만들어주기위해 select문에 N번 실행됩니다.
Lazy모드는 당장 N+1문제가 발생하지 않지만 연관된 관계를 참조하려할 때 JPA에서는 연관 관계를 만들기위해 조회가 이뤄집니다. 
 
 **해결책**
 1. fetch join : fetch join은 즉시 연관 엔티티를 가져오도록 할 수 있습니다. SQL자체에서 연관 엔티티를 가져오도록 강제합니다. fetch join은 inner join을 사용해서 연관 관계를 만들어냅니다.
 2. @EntityGraph : EntityGraph를 사용하면 명시적으로 가져올 엔티티를 정할 수 있습니다. EntityGraph는 Outer join을 사용해서 연관 관계를 만들어냅니다.

 이 두가지 방법은 카테시안 곱이 발생해서 데이터의 중복이 발생합니다. 이를 해결하기위해 distinct로 조회하거나 자료구조로 set을 사용할 수 있습니다.
 
 3. batch size : OneToMany관계에 batch size를 설정해서 한번에 불러올 데이터 수를 지정할 수 있습니다. where in구문을 사용하기 때문에 join이 사용되지 않지만 N+1문제를 해결할 수 있습니다.

</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. 영속성 컨텍스트는 무엇인가요?</strong></summary></br>
    
영속성 컨텍스트는 엔티티를 영구 저장하는 환경입니다. 엔티티 매니저로 엔티티를 저장하거나 조회하면 영속성 컨텍스트에서 엔티티를 보관하고 저장합니다.
영속성의 생명주기는 비영속, 영속, 준영속, 삭제로 4가지가 있습니다.   
**비영속 상태**는 엔티티의 객체는 생성되었지만 아직 저장하지 않아 영속성 컨텍스트나 데이터베이스와 관련 없는 상태를 말합니다.    
**영속 상태**는 영속성 컨텍스트가 관리하는 상태를 말합니다.   
**준영속 상태**는 영속성 상태인 엔티티를 더이상 영속성 컨텍스트에서 관리하지않는 상태입니다. 준영속상태는 1차캐시부터 쓰기 지연 저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거됩니다.    
**삭제**는 엔티티가 영속성 컨텍스트와 데이터베이스에서 삭제된 상태입니다.       

영속성 컨텍스트는 엔티티의 식별자(@Id)를 통해 구분합니다. 따라서 영속 상태는 반드시 식별자가 있어야합니다. 
영속성이 데이터베이스와 동기화하는 과정은 보통 트랜잭션이 커밋되는 순간이며 이를 flush라고합니다.
영속성은 1차 캐시, 동일성 보장, 변경 감지, 쓰기 지연등의 장점이있습니다.  

**1차 캐시**  
영속화가 된 엔티티는 1차 캐시에 저장되어 관리되며 1차 캐시에 존재한다면 데이터 베이스를 조회하지 않고 조회가 가능하므로 성능상 이점이 있습니다. 동일한 엔티티를 여러번 조회해도 
1차 캐시에 있는 값을 반환하여 각각의 엔티티는 동일성을 보장합니다.  
**쓰기 지연**  
엔티티 매니저는 트랜잭션이 커밋되기 전까지 엔티티를 데이터베이스에 저장하지 않습니다. 내부 쿼리 저장소를 통해 insert SQL을 저장하며 트랜잭션을 커밋할 때 쿼리를 데이터 베이스로 전송합니다.
한번에 쿼리를 전달하므로써 성능상 이점을 얻을 수 있습니다.  
**변경 감지**  
영속성 컨텍스트는 영속상태의 엔티티의 변경을 추적합니다. JPA는 엔티티를 영속성 컨텍스트에 보관할 때 최초의 상태를 스냅샷합니다. 그리고 flush시점에서 스냅샷과 비교하여 변경사항이 감지되면
update 쿼리를 쓰기 지연 저장소에 추가하고 SQL을 데이터베이스로 보냅니다. 따라서 JPA에서는 별도의 update메서드가 존재하지 않습니다.

flush는 엔티티 매니저의 flush()메소드를 직접 호출하거나, 트랜잭션 커밋, JPQL을 실행하므로서 동작하게 할 수 있습니다.


</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. JPA에서 즉시 로딩과 지연 로딩은 무엇인가요?</strong></summary></br>
    
JPA는 객체 그래프로 연관된 객체를 탐색합니다. 그러기 위해서는 엔티티에 객체 필드가 존재해야 합니다. 하지만, 사용하는 쿼리에 따라 연관 관계를 참조할 필요가 없을 수도 있습니다.
JPA가 지원하는 즉시로딩은 엔티티를 조회할 때 연관된 객체를 함께 조회하는 것을 말하며, 지연 로딩은 연관된 객체를 함께 조회하지 않고 사용하는 시점에서 조회하는 것을 말합니다.
</details></br>


<details>
    <summary style="font-size : 20px;"><strong> Q. JPA의 양방향 매핑 관계에서 잘못하면 무한루프가 발생할 가능성이 있는데 이런 원인은 무엇이고 해결책은 어떤 것인가요?</strong></summary></br>
    
이런 상황은 보통 엔티티를 JSON으로 변환하려는 상황에서 발생합니다. 회원, 팀이 양방향 관계에 놓여있다고 했을 때 회원 엔티티를 JSON으로 변환 한다고 가정해보겠습니다.
JSON으로 변환과정에서 팀의 엔티티까지 변환시키려고 할 것입니다. 그렇다면 팀에 속한 필드도 JSON으로 변환되는 과정이 필요한데, 
이때 팀에 속한 회원도 JSON으로 변환하려고합니다. 결국에는 팀에서는 회원을, 회원에서는 팀을 JSON으로 변환시키려는 과정에서 무한 루프가 발생합니다.
그래서 보통 dto를 만들고 JSON으로 변환할 데이터만 정의해서 그 dto로 JSON을 만듭니다. 이외에도 JSON라이브러리에서는 무한 루프에 빠지지 않게 하는 어노테이션이나 기능을 제공합니다.
</details></br>


<details>
    <summary style="font-size : 20px;"><strong> JPA의 mappedBy속성은 무엇인가요?</strong></summary></br>
    
먼저, 테이블에서 양방향 관계와 객체의 참조 관계는 차이가 있습니다. 테이블에서는 외래키를 사용하여 양쪽에서 조인을 할 수 있습니다. 하지만 객체는 단방향 참조를 사용합니다. 
양방향을 참조하는 상황에서 객체의 참조는 둘이지만 외래키는 하나인 상황이 발생합니다. 따라서 두 객체중 테이블의 외래키를 관리할 주인을 설정해줘야합니다. 
주인은 외래키의 등록, 수정, 읽기등이 자유롭지만 주인이 아닌 곳에서는 읽기만 가능합니다. mappedBy속성은 외래키를 관리하는 주인을 설정하는 속성입니다. 
주인이 아닌 경우 mappedBy속성을 사용해서 주인을 지정해야합니다.
</details></br>

<details>
    <summary style="font-size : 20px;"><strong> JPA에서 프록시는 무엇인가요?</strong></summary></br>
     
지연 로딩을 사용하기위해 JPA에서는 실제 엔티티 객체 대신 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요합니다. 이것을 프록시 객체라고 합니다. 
엔티티 매니저에서 getReference()메서드를 사용하면 프록시 객체를 얻을 수 있습니다. 이 프록시 객체는 엔티티의 상속을 통해 만들어진 것으로 실제 엔티티와 겉모습이 같습니다.
프록시 객체에 값을 얻기위해 호출하면 엔티티 정보를 얻어오기위한 DB조회를 조회해 엔티티를 가져옵니다. 이를 프록시 초기화라고합니다. DB조회로 영속성 컨텍스트에 저장된 엔티티를 
프록시 객체가 참조하면서 값을 반환합니다. 이런 원리로 지연 로딩이 가능합니다.
</details></br>
