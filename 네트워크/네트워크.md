# 네트워크

<details>
    <summary style="font-size : 20px;"><strong> Q. OSI 7 layer에 대해 설명해주세요</strong></summary></br>

OSI 7 Layer는 physical, link, network, transport, session, presentation, application layer로 구성되어있습니다.  

- Physical layer에서는 패킷을 전기적인 신호로 encoding하고 전기적인 신호를 패킷으로 decoding하는 과정을 진행합니다. 데이터를 전송하는 역할을 맡으며 하드웨어적으로 처리됩니다. (케이블, 허브, 리피터)
- Link layer에서는 Physical layer로 송수신되는 정보를 관리하여 안전하게 전달되도록 하는 역할입니다. 프레임에 Mac주소를 부여하고 에러 검출, 재전송의 기능을 갖고있습니다. (스위치, 브릿지)
- Network layer에서는 패킷을 전달하기위해 목적지 주소로 찾아가는 라우팅이 이뤄집니다. 
- Transport layer는 port번호를 사용해 어떤 프로세스에게 데이터를 전달할지 결정합니다. 메시지가 큰 경우 이를 나눠서 네트워크 계층으로 전달하고, 받은 패킷은 재조립하여 상위 계층으로 전달합니다.
- Session layer는 통신에 사용되는 세션을 만들고 없애는 역할을 합니다.
- Presentation layer는 데이터를 압축하고 데이터를 암호화, 복호화 하는 역할을 담당합니다.
- Application layer는 사용자 정의 애플리케이션이 실행되는 영역입니다.

</details></br>
    
<details>
    <summary style="font-size : 20px;"><strong> Q. TCP/IP는 무엇인가요?</strong></summary></br>
    
TCP/IP는 현대 인터넷에서 사용하는 네트워크 모델로서 network interface, internet, transport, application layer로 구성되어있습니다. TCP/IP는 패킷 통신 방식의 인터넷 프로토콜인 IP와 전송 계층의 TCP프로토콜로 이뤄져있습니다. IP는 패킷의 전달 여부와 순서를 보장하지않습니다. TCP는 IP위에서 동작하는 프로토콜로서 신뢰성있는 데이터 전송을 보장하고 패킷의 순서도 조립해줍니다. HTTP, FTP, SMTP등 많은 애플리케이션 프로토콜이 TCP, IP 프로토콜 위에서 동작하기 때문에 묶어서 TCP/IP라고 부르기도 합니다.

- network interface layer는 데이터의 물리적 전송을 담당하는 계층으로 OSI 7layer에서 물리 계층과 링크 계층에 해당됩니다. 
- internet layer는 패킷을 전달하기위해 목적지 주소로 찾아가는 역할을 담당합니다.
- transport layer는 데이터 전송을 담당하는 계층으로 대표적인 프로토콜로 TCP, UDP가 있습니다.
- application layer는 사용자 정의 애플리케이션이 실행되는 영역입니다.
</details></br>


<details>
    <summary style="font-size : 20px;"><strong> Q. TCP프로토콜은 어떤 특징이 있나요? </strong></summary></br>
    
TCP는 transport layer의 프로토콜로서 연결 지향형이며 신뢰성있는 데이터 전송 프로토콜입니다.

**TCP는 연결 지향형 프로토콜로서 가상회선방식을 사용합니다.**  
최초에 통신에서 3way handshake를 통해 논리적으로 가상회선을 만들어 통신에 사용합니다. 연결 종료 할 때는 4way handshake과정을 가집니다. 

**TCP는 신뢰성있는 데이터 전송 프로토콜입니다.**  
TCP는 패킷에 순서를 부여하고 수신측에서 재조립해 순서를 유지하며 오류가 난 데이터를 재전송합니다. 오류 상황은 패킷이 유실되거나, timeout, 부정 응답을 받은 상황이 있을 수 있습니다. 이때 TCP프로토콜은 재전송 기법을 사용합니다. 대표적으로 Go back N방식과 selective Repeat방식이 있는데, Go back N방식은 오류가 난 패킷 번호로부터 전체를 재전송하는 방식을 말합니다. 오류가 발생한 패킷 뒤에 정상적으로 도착한 패킷은 폐기되며 재전송되는 패킷을 기다립니다. Selective Repeat방식은 오류가 발생한 패킷만을 재전송합니다. 두 방식의 차이점은 Go Back N방식은 오류가 발생한 패킷 이후에 전체를 재전송하여 비효율적인면이 있지만 따로 버퍼를 관리가 필요 없습니다. Selective Repeat 방식은 오류가 발생한 패킷을 다시 재정렬해야하기 때문에 버퍼를 관리해야합니다. 

**TCP는 흐름제어의 특징이 있습니다.**   
수신측에서 감당할 수 없을 정도의 많은 데이터를 받게되면 버퍼 오버플로우가 발생하는데 흐름제어는 이점을 해결해줍니다. 흐름제어에 stop and wait 방식을 사용해서 정상적으로 패킷을 수신했다는 응답을 받은 다음에야 데이터를 보내는 방식도 있고, slide window방식으로 일정 윈도우 크기만큼은 확인 응답없이 전송하고 확인 응답이 도착한 경우 window를 슬라이딩해가며 다음 패킷을 전송하는 방식이 있습니다. TCP프로토콜은 헤더에 window size를 지정하여 송신측과 수신측의 window size를 조절합니다.

**TCP는 혼잡제어의 특징도 있습니다.**   
네트워크는 다같이 나눠쓰는 자원으로서 네트워크의 과부하를 막기위해 혼잡제어가 사용됩니다. 네트워크에 부하가 있는 상황에서 window사이즈를 줄이는 방식을 사용합니다. Window size는 네트워크 혼잡도를 고려한 window사이즈와 수신측에서 보내준 윈도우 크기중 작은 것을 사용합니다. 혼잡 회피의 기본적인 철학은 네트워크가 혼잡하면 윈도우 사이즈를 줄이고 아니면 늘리자는 것입니다.  

AIMD방식은 네트워크에 문제가 없다면 혼잡 윈도우 크기를 1씩증가시키고 혼잡하다면 절반으로 줄이는 방식입니다. 나중에 네트워크에 진입하는 쪽이 불리하지만 시간이 지남에 따라 윈도우 크기가 평형상태로 수렴합니다. 네트워크에 문제가 없는 상황에서 초반에 대역폭을 제대로 활용하는데 시간이 걸린다는 단점이 있습니다.   

Slow start 방식은 네트워크에 문제가 없다면 지수적으로 윈도우 크기를 늘리고 혼잡하다면 크기를 1로 만드는 방식입니다.
혼잡제어 정책에는 3ack duplicate, time out, threshold가 사용됩니다.
3ack duplicate는 네트워크에 문제가 발생해 3번의 같은 패킷 번호로 ack가 응답한 상황을 의미합니다. 이런 상황에서는 time out을 기다리지 않고 빠른 재전송을 사용합니다.
Threshold는 혼잡 윈도우크기의 임계점을 말합니다.
혼잡제어 정책은 여러가지가 있지만 기본적으로 네트워크가 혼잡하면 윈도우 사이즈를 줄이고 아니면 늘리는 철학을 가지며 3ack duplicate, time out, threshold등을 고려해 장애 상황판단하고 윈도우 사이즈를 조절합니다.

</details></br>


<details>
    <summary style="font-size : 20px;"><strong> Q. TCP의 3way handshake, 4way handshake는 어떻게 이뤄지나요?</strong></summary></br>

3way handshake
1. 클라이언트는 SYN 패킷을 전송하여 접속을 요청합니다. 클라이언트는 SYN패킷을 보냄과 동시에 SYN_SENT상태가 되고 SYN/ACK응답을 기다립니다.
2. 서버는 SYN 패킷을 받고 클라이언트에게 요청을 수락하는 ACK/SYN패킷을 보냅니다. 이때 서버는 SYN_RCVD상태로 클라이언트의 ACK패킷을 기다립니다.
3. 클라이언트는 ACK패킷을 보낸다. 서버에서 ACK패킷을 받게되면 ESTABLISHED상태가 되고 데이터 통신을 시작한다.

4way handshake
1. 클라이언트는 접속 종료를 위해 서버에게 FIN을 보내고 FIN_WAIT1상태가 됩니다.
2. 서버는 클라이언트가 접속을 종료한다는 것을 알게되고 CLOSE_WAIT상태로 변경한뒤 ACK 패킷을 보낸다. 
3. ACK를 받은 클라이언트는 FIN_WAIT2상태가 되고 서버는 close()함수를 호출한 뒤 FIN패킷을 보낸다. 이때, 서버는 LAST_ACK상태가 된다.
4. 서버가 보낸 FIN패킷을 수신하면 클라이언트는 ACK를 보내고 TIME_WAIT상태가 된다.
5. 서버는 ACK를 받고 CLOSED상태가 된다.

</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. UDP프로토콜은 어떤 특징이 있나요?</strong></summary></br>
    
UDP는 transport layer에서 데이터를 데이터그램 단위로 처리하는 프로토콜로서 비연결형, 비신뢰성 전송 프로토콜입니다.
UDP는 데이터 전송 방식으로 데이터그램방식을 선택합니다. TCP와는 다르게 패킷 전송시마다 경로는 독립적이며 패킷 또한 독립적인 관계를 지닙니다.

UDP는 재전송, 혼잡제어, 연결 과정등이 없기 때문에 TCP에 비해 통신속도가 빠른 특징을 가지고 있습니다. 하지만 비신뢰성 프로토콜로서 데이터의 신뢰성보다 연속성이 중요한 스트리밍 서비스에 사용됩니다.


</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. TCP와 UDP는 어떤 차이점이 있나요?</strong></summary></br>
    
TCP와 UDP는 체크섬을 이용하여 데이터 오류검사하며 port번호를 통해 주소를 지정하는 공통점이 있습니다. 
차이점은 TCP는 가상 회선방식의 연결형이지만 UDP는 데이터그램 방식의 비연결형 프로토콜이고 TCP는 패킷 순서를 보장하고 
재전송을 통해 신뢰성있는 데이터 전송프로토콜이지만 UDP는 패킷 순서를 보장하지 않고 수신여부를 확인하지 않습니다.
그렇기 때문에 UDP는 속도면에서는 빠르다고 할 수 있습니다. 통신 방식은 TCP는 1:1통신만 가능하지만 UDP는 1:1, 1:N, N:N통신 모두 가능합니다.

</details></br>

## HTTP
<details>
    <summary style="font-size : 20px;"><strong> Q. HTTP 프로토콜은 무엇인가요?</strong></summary></br>
    
인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 프로토콜을 말합니다. 
</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. HTTP 프로토콜의 특징은 무엇인가요?</strong></summary></br>
    
**비연결성**  
비연결성은 클라이언트와 서버 사이에서 요청과 응답이 종료되면 연결을 끊는 성질입니다.
비연결성의 장점은 연결 유지를 위한 리소스가 불 필요하다는 점있습니다. 반면 동일한 클라이언트가 지속적으로 연결 해제를 반복하면 그에 따른 오버헤드가 발생하는 단점이 있습니다. 이에 대한 해결책으로 keep alive 속성이 있습니다. time out과 max connection수를 설정해 이전에 사용했던 연결을 재사용할 있습니다.

**stateless**    
상태를 유지하지 않는 성질입니다. 상태를 유지하지 않기 때문에 서버는 클라이언트가 이전에 접속한 클라이언트인지 확인할 수 없습니다. 이런 특징으로 웹사이트에 로그인했을 때, 다른 페이지로 이동하면 로그인이 해제되는 문제가 발생합니다. 이에 대한 해결책으로 쿠키와 세션이있습니다.

**응답 상태 코드**      
서버는 요청에 대한 처리 상태를 숫자로서 반환하는데 이것을 상태 코드라고 합니다.
상태 코드에 대한 요약은 아래와 같습니다.  
100 ~ 109 : 요청을 받았으며 작업을 계속진행  
200 ~ 206 : 요청 성공   
300 ~ 305 : 리다이렉션   
400 ~ 415 : 클라이언트 에러   
500 ~ 505 : 서버에러   
 
**HTTP 메서드**      
클라이언트는 서버에 요청할 때 어떤 행위를 목적으로 요청을 전송하는 것인지 http메서드를 통해 명시할 수 있습니다.   
HEAD : 서버 응답이 메시지 본문없이 헤더만을 반환  
GET : 서버에게 리소스 조회        
POST : 서버에게 데이터를 메시지 body에 담아 전송, 리소스 저장   
PUT : 리소스 수정  
DELETE : 리소스 삭제    
OPTIONS : 서버가 어떤 메서드를 지원하는지 조회    

**HTTP 메시지**    
HTTP 메시지는 시작 라인(Request Line), 헤더 (Header), 본문 (Body)로 구성되어 있습니다.
Request Line은 요청시 http method, url, 프로토콜 버전, 응답시 프로토콜 버전과 상태코드가 포함됩니다.  
Header는 패킷에 대한 메타데이터를 담고 있습니다.  
Body는 메시지의 본문을 담습니다(생략 가능)
</details></br>


<details>
    <summary style="font-size : 20px;"><strong> Q. HTTP 프로토콜의 버전별 비교를 해주세요 </strong></summary></br>
    
**HTTP 0.9**  
단순한 get방식만 가능하고 http 헤더가 없었으며 html문서만 전송이 가능했습니다.

**HTTP 1.0** 
상태코드, HTTP헤더가 추가됐고 헤더의 Content-Type으로 HTML이외에 다른 문서들도 전송이 가능해졌습니다. 또한, POST, HEAD 메서드가 추가되었습니다.

**HTTP 1.1**  
OPTION, PUT, DELETE, TRACE메서드가 추가되었습니다.  

**Keep-alive**  
Keep-alive 속성이 추가되서 매 요청 마다 TCP connection을 새로 만드는 대신 일정 시간안에 재요청이 발생하면 기존의 connection을 활용하도록 하는 기능이 추가되었습니다. 

**파이프 라인**   
HTTP1.1는 기본적으로 연결당 하나의 요청과 응답을 처리하기 때문에 동시 전송 문제와 다수의 리소스를 처리하는데 있어 성능 이슈가있습니다. HTTP1.1은 파이프 라인 구조로 이런 문제를 해결하고자 했습니다. 하나의 커넥션에서 여러개의 요청과 응답을 받을 수 있으며 이전 요청의 완료를 기다리지 않고 다음 요청을 전송할 수 있습니다. 하지만, 응답은 서버의 요청 순서에 맞게 반환되야합니다. 따라서 앞선 요청에 대한 응답이 지연되는 상황이라면 그 이후 응답도 영향을 받습니다. (head of blocking 문제) 

**HTTP 2**  
HTTP2는 tls적용이 필수는 아니지만 대부분 브라우저에서 tls가 적용되어있지 않으면 HTTP1.1로 동작합니다. 

**Multiplexed Streams**    
HTTP2는 데이터의 전송 단위에서 변화가 있는데 프레임이라는 데이터 전송단위를 사용합니다. 이 프레임이 모여 하나의 요청, 응답을 의미하는 메시지를 구성하고 메시지가 모여 스트림을 구성합니다. 하나의 커넥션에서는 여러 스트림이 존재할 수 있고 스트림간 순서가 뒤섞일 수 있는데, 프레임에는 프레임 헤더가 존재하여 이를 통해 스트림을 식별할 수 있습니다. 이러한 방식은 HTTP 메시지를 독립된 프레임으로 세분화하고 이 프레임을 인터리빙한 다음, 다른 쪽에서 다시 조립할 수 있기 때문에 여러 요청과 응답을 차단없이 단일 연결을 사용해서 병렬적으로 전달할 수 있습니다. 

**헤더 압축**    
HTTP1.1은 여러 요청에서 쿠키 정보를 포함하여 동일한 헤더를 중복해서 전송하여 데이터 전송량이 많았습니다. HTTP2는 Header Table을 사용해서 중복 Header는 index값을 전송하고 중복되지않은 Header정보는 허프만 코드로 인코딩하여 필드의 개별 값을 압축합니다. 이러한 방식을 HPACK 압축 방식으로 부르고 전송되는 데이터의 양을 줄일 수 있습니다.

**서버 푸시**  
기존의 http 1.1버전에서 하나의 요청에대해 하나의 응답을 반환했다면 HTTP 2는 server push를 사용해서 클라이언트가 요청한 리소스 이외에도 다른 리소스를 포함하여 응답할 수 있습니다. HTTP1.1에서는 HTML문서를 요청하면 브라우저에서 태그를 파싱하고 추가적으로 필요한 리소스를 다시 요청하지만, HTTP2는 이런 추가적인 리소스를 포함해서 응답해줄 수 있습니다. 따라서 하나의 요청에 여러 응답을 반환할 수 있어 데이터 전송효율을 높일 수 있습니다. (PUSH_PROMISE 프레임을 사용하면 서버가 푸시한 리소스를 요청하지 않도록 할 수 있음)

</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. 쿠키와 세션의 차이점은 무엇인가요?</strong></summary></br>
    
쿠키는 key, value형태의 데이터입니다. 브라우저에 쿠키를 저장하고 서버로 요청시 쿠키와 함께 전송하는 방식입니다. 브라우저를 종료해도 만료시간이 지나지않으면 쿠키가 삭제되지않습니다.

세션은 서버에 사용자의 정보를 저장하는 구조입니다. 서버가 세션을 관리해야하므로 사용자가 늘어날 시 서버에 부담을 줄 있습니다. 클라이언트는 서버에 접속하면 세션 id를 발급받고 세션 id에 대해 쿠키를 만들어 저장합니다. 이후 이 쿠키를 서버로 요청할 때 같이 전송합니다. 브라우저를 종료하면 만료시간에 상관없이 쿠키가 삭제됩니다.

세션도 결국 쿠키를 사용하지만 둘의 차이점은 정보가 저장되는 위치입니다. 또한, 라이프사이클이 다릅니다. 세션이 서버에서 처리되기 때문에 보안면에서 우수하지만 세션이 많을수록 서버에 부하가 발생합니다.

</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. HTTPS는 무엇이고 왜 필요한가요?</strong></summary></br>
    
Https는 기존 http프로토콜에 ssl, tls계층을 추가한 프로토콜 입니다. https가 등장한 이유는 http가 보안상 취약하기 때문입니다. 
http의 문제점은 암호화 되지 않은 평문으로 도청이 가능하며, 통신 상대를 확인하지 않기 때문에 위장한 상대에게 요청,응답을 보낼 수도 있고, 
메시지의 내용이 변조되어 도착하는 중간자 공격을 받을 수 도 있습니다. https는 공개키, 공통키를 사용한 방식으로 메시지를 암호화하고, 
인증서를 통해 통신 상대를 증명하며, 디지털 서명을 통해 데이터 위조를 확인할 수 있습니다.
</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. 인증서는 무엇이고 왜 쓰이나요?</strong></summary></br>
    
https에서 통신상대를 확인할 때 인증서가 사용됩니다. 인증서가 사용되는 절차는 다음과 같습니다.
먼저, 서버는 서버의 정보와 공개키를 CA(제 3 인증기관)에 제출합니다. 인증기관에서는 공개키에 디지털 서명을하고 공개키를 담은 인증서를 만들어 발급해줍니다. 
서버는 클라이언트의 요청이오면 인증서를 전송하고, 클라이언트는 사전에 브라우저에 내장된 인증기관의 공개키를 사용해 복호화합니다. 
이 작업을 통해 웹서버의 공개키를 인증기관이 진짜 인증했다는 사실을 파악하며 서버의 공개키를 신뢰할 수 있습니다. 
</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. 디지털 서명은 무엇이고 왜 쓰이나요?</strong></summary></br>
    
디지털 서명은 메시지의 위조를 검증하는데 사용합니다. 송신자의 원본 데이터를 해싱하고 private key로 암호화합니다. 
암호화된 내용을 메시지에 추가해 전송하면 수신자는 송신자의 public key로 암호화된 메시지를 복호화합니다.
복호화된 메시지와 원본 데이터를 해싱한 결과가 같으면 데이터의 변조가 이뤄지지 않았다는 사실을 알 수 있습니다.
</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. 공통키 암호와 방식과 공개키 암호와 방식을 비교해주세요.</strong></summary></br>
    
공통키 방식은 클라이언트와 서버가 동일한 키를 암호화, 복호화에 사용합니다. 공통키 방식에는 딜레마가 존재하는데, 키를 교환하지 않으면 암호화 통신을 할 수 없고, 키를 교환한다면 공통키는 탈취당할 위험이 있습니다.   
공개키 암호화 방식은 누구에게나 공개하는 공개키와 비밀키를 가지고 암호화를 진행합니다. 클라이언트는 서버의 공개키로 메시지를 암호화하고 서버는 비밀키로 내용을 복호화합니다. 비밀키를 전달하는 과정이 없어 안전한 방식이지만 처리 속도가 느립니다.
https는 두 방식을 혼합하여 사용합니다. 안전한 키 교환을 위해 공개키 암호화 방식으로 공통키를 교환하는 과정을 거치고 그 이후에는 공통키로 통신합니다. 
</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. HTTP 캐시는 어떻게 이뤄지나요?</strong></summary></br>
    
HTTP 캐시는 헤더에 관련 값을 설정하므로서 캐시할 수 있습니다.

**Last Modified : 마지막 수정 시간**
1.	브라우저는 최초의 응답을 받은 last modified를 if-modified-since헤더에 포함 시켜 요청을 전송
2.	서버측에서 파일의 수정 시간을 확인해보고 if-modified-since와 동일하다면 304 not modified응답, 다르면 200 ok 응답과 새로운 last-modified를 응답 헤더에 전송
3.	브라우저는 304라면 캐시된 컨텐츠를 로드, 200이라면 새로 컨텐츠를 받은 뒤 last-modified를 업데이트  

**Etag : 리소스에 대한 고유 값**
1.	브라우저는 최초 응답으로 받은 etag를 if-none-match라는 헤더에 포함시켜 페이지를 요청
2.	서버는 요청 파일의 etag값을 if-none-match에 담긴 값과 비교해서 동일하면 304 not modified,  다르면 200 ok와 새로운 etag값을 헤더에 담아 응답
3.	브라우저는 304라면 캐시된 컨텐츠를 로드, 200이라면 새로 컨텐츠를 받은 뒤 last-mofified를 업데이트 


**Expire : 캐시 만료 시간**
1.	브라우저는 최초 받은 expires 시간을 비교해서 기간 내라면 서버에게 요청을 보내지 않고 바로 캐시된 컨텐츠를 로드합니다. 만약 기간이 만료되었다면 저장된 캐시에 대한 validation 작업을 수행합니다.

**Cache Controll : 캐시 매커니즘을 정하는 헤더, no-cache, no-store, max-age등을 설정가능**
1.	브라우저는 최초 응답 시 받은 Cache-control중 max-age값을 GMT와 비교해서 기간내 라면 서버를 거치치않고 캐시된 컨텐츠를 로드합니다. 만약 기간이 만료되었다면 저장된 캐시에대한 validation 작업을 수행합니다.

Cache Controll의 max-age는 Expire보다 우선시 됩니다.


</details></br>

## 기타 지식
<details>
    <summary style="font-size : 20px;"><strong> Q. 로드 밸런싱은 무엇인가요?</strong></summary></br>
    
로드 밸런서는 부하를 분산하는 역할을 합니다. 서버의 규모가 커질수록 scale out하여 서버를 증설할 수 있는데 로드 밸런서는 여러 서버에 대하여 요청을 나눠주는 기능을 수행합니다.

로드 밸런서 알고리즘에는 RR, WRR, IP Hash, Least Connection방식등이 있습니다. RR는 여러 서버에 대하여 순차적으로 부하를 분산하는 방식이고 WRR은 RR방식에 가중치를 주어 부하를 분산합니다. RR방식은 서버 스펙이 유사할 때, WRR방식은 서버 사양에 차이가 있을 떄 활용합니다. IP HASH방식은 ip주소를 해싱하여 특정 서버로 연결해줍니다. 같은 ip에 대해 동일한 서버와의 연결을 보장합니다. least connection방식은 요청이 들어온 시점에서 가장 적은 연결상태를 보이는 서버에게 요청을 보냅니다.
</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. NAT는 무엇인가요? </strong></summary></br>
    
NAT는 Network Address Translation으로 네트워크 주소를 변환하는 기술을 의미합니다. NAT는 사설 ip와 공인 ip사이에 변환을 담당합니다. 즉, 내부망에서는 사설 IP를 사용하고 외부와 통신할 때 NAT를 거쳐 공인 IP주소로 변환합니다. 외부와 통신하는 관점에서 내부 사설 IP를 노출하지 않아 보안에 유리합니다. NAT는 static NAT, dynamic NAT, PAT등의 방식이 있습니다. Static NAT는 1:1통신에 사용되며 사설 IP와 공인 IP가 1:1로 대응하여 외부에서도 사설IP로 접근 할 수 있게 하는 방식입니다. Dynamic NAT는 공인 IP주소 보다 사설 IP주소가 많을 때 사용하는 방식으로, 공인 IP를 pool로 만들어 주소를 mapping시키는 작업을 진행합니다. NAT테이블에 매핑정보를 동적으로 기록하는 방식입니다. PAT방식은 1:N방식으로 사용되며 하나의 공인 IP에 포트번호를 할당하여 사설 IP와 연결하는 방식을 말합니다. 
</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. 공인 IP와 사설 IP는 무엇인가요?</strong></summary></br>
    
공인 아이피는 세계에서 단 하나만 존재하는 IP주소입나다. ISP(인터넷 서비스 공급자)로부터 공인 ip할당 받고 공인 ip를 사용하여 외부와 통신할 수 있습니다.
사설 아이피는 공인 ip의 부족으로 사설 ip의 개념이 등장했습니다. 공유기를 이용해 만들 수 있는 가상의 IP주소로서 가상ip, 로컬 ip라고도 불리며 외부에서 사설 ip에 직접 접근할 수 없습니다. 
먼저 공인 IP에 접근한 뒤 사설 ip에 접근 할 수 있습니다. 즉, 내부망 전용 ip라고 생각할 수 있습니다.

</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. 브라우저에 URL을 입력하면 어떤일이 일어나나요?</strong></summary></br>
    
1. 브라우저에 url을 입력합니다.     
2. 브라우저에서는 url의 내용을 파싱하여 프로토콜, url, 포트번호등의 정보를 확인합니다.   
3. HSTS를 조회합니다. HSTS는 요청하는 서버에서 HTTPS통신을 사용한다고 브라우저에 알리는 보안기능으로서 HSTS목록에 있다면 요청을 HTTPS로 보냅니다.    
4. DNS서버를 사용하여 도메인 주소를 IP로 변환합니다.  
5. ARP를 통해 IP주소를 MAC주소로 변환합니다. ARP는 네트워크 계층의 주소와 링크 계층 주소 사이의 변환을 담당하는 IP프로토콜입니다. 랜카드에 있는 MAC주소를 얻어옵니다.      
6. 데이터를 전송하기위해 소켓을 열고 대상서버와 TCP프로토콜을 사용해 연결합니다.  이 과정에서 3way handshake가 일어납니다. 만약 https통신을 사용한다면 추가적으로 SSL 네고시에이션 과정을 거칩니다.   
7. https/ http 프로토콜을 사용하여 요청, 응답합니다.   
8. 통신이 종료되면 연결을 해제하기 위해 4way handshake가 수행됩니다.   
9. 브라우저에서 수신한 응답을 해석해서 랜더링해줍니다.     
</details></br>


<details>
    <summary style="font-size : 20px;"><strong> Q. URL이 IP주소로 변환되는 과정을 설명해주세요.</strong></summary></br>
    
1. 브라우저에 URL을 입력하면 Local DNS서버를 확인하고 캐시된 값이 있으면 IP주소를 반환합니다. 
2. 캐시된 값이 없다면 요청은 root name server로 전달하고 IP주소에 대한 정보가 없다면 TLD 네임서버에 IP주소를 요청합니다.
3. TLD 네임서버에서 IP주소에 대한 정보가 없다면 해당 도메인을 관리하는 DNS서버의 정보를 전달합니다.
4. 해당 도메인을 관리하는 DNS서버에 ip주소를 질의하고 Local DNS서버는 응답을 받습니다.
5. Local DNS서버는 도메인에대한 ip주소를 캐싱하고 ip주소를 전달합니다.
</details></br>


