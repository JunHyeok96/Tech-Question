# JAVA
#### Q. JDK, JRE, JVM의 차이는?  
**JDK** : 자바 개발 도구의 약자로 JRE와 개발에 필요한 도구를 포함합니다. JRE + 개발 도구  
**JRE** : 자바 실행 환경의 약자로로 JRE는 JVM이 자바 프로그램을 실행시킬 때 필요한 라이브러리 파일과 기타 파일들을 가지고 있습니다. JVM + 시스템 라이브러리   
**JVM** : 자바 가상 머신의 약자로 자바 소스 코드를 컴파일하여 만든 바이트 코드를 실행할 수 있습니다.   
</br>
자바는 운영체제나, 하드웨어에 상관없이 JVM만 있으면 실행할 수 있기 때문에 플랫폼 독립적입니다. JVM은 각기 다른 플랫폼에서 동일한 실행환경을 제공하고 플랫폼에 종속적입니다.   
</br></br>

#### Q. JAVA의 실행과정을 말해주세요.  
자바 코드를 컴파일하면 바이트코드가 생성되고 JVM은 바이트 코드를 운영체제가 이해할 수 있는 기계어로 바꿔 실행시켜주는 역할을 함
</br></br>

#### Q. JAVA는 인터프리터 언어인가요? 컴파일 언어인가요?  
자바 코드를 컴파일하여 바이트 코드를 생성하고 JVM의 execution engine이 runtime data area에 적재된 바이트 코드를 기계어로 번역하여 실행하는 역할을 합니다. 따라서, 컴파일과 인터프리터가 동시에 작동하는 하이브리드 성향을 가지고 있습니다.
자바가 느리다고 하는 이유 중 하나가 이런 실행 방식과 연관이 있습니다. 
하지만 JIT 컴파일러를 사용하면 매번 기계어로 번역하지 않고 이전에 실행한 코드를 캐싱하여 재사용하기 때문에 예전의 자바 인터프리터 방식에 비해 훨씬 빨라졌다고 합니다.
</br></br>

#### Q. JVM 구조에 대해서 설명해주세요.
JVM은 class loader, execution engine, garbage collector, runtime data area로 구성됩니다.  
- Class loader는 런타임시 .class파일을 읽어 runtime data area의 메서드 영역에 적재하는 역할을 합니다.  
- Execution engine은 Runtime Data Area의 메서드 영역에 적재된 바이트 코드를 기계어로 변경해서 실행하는 역할을 합니다.  
- Garbage collector는 heap 메모리에 생성된 객체 중 참조되지 않는 객체들을 탐색 후 제거하는 역할을 한다. GC는 데몬 스레드로 수행되며, 수행 중에는 모든 스레드가 중단됩니다.    
- Runtime Data Area는 JVM의 메모리 영역으로 자바 애플리케이션이 실행될 때 사용되는 데이터들을 적재하는 영역입니다. 이 영역은 메소드 영역, 힙 영역, 스택 영역, pc레지스터, 네이티브 메서드 스택으로 구분됩니다.  
</br></br>

#### Q. JVM의 메모리 구조는 어떻게 구성되어 있나요?    
JVM의 메모리 구조는 메서드(클래스/static) 영역, 힙 영역, 스택 영역, pc 레지스터, 네이티브 메서드 스택으로 구성됩니다. 
- 메서드 영역에서는 프로그램이 실행중에 클래스가 사용되면 JVM은 해당 클래스의 .class파일을 읽어 클래스에 대한 정보를 저장하는 영역입니다. static 맴버, static 메서드도 이 영역에 해당됩니다.
- 힙 영역은 new 키워드로 생성된 객체와 배열이 저장되는 영역이다. 메소드 영역에 로드된 클래스만 생성 가능합니다. GC에의해 참조되지 않는 메모리가 제거됩니다. 
- 스택 영역은 지역 변수, 매개 변수, 리턴 값등이 생성되는 영역입니다. 
- PC 레지스터는 현재 스레드가 실행되는 부분의 주소와 명령을 저장하는 영역입니다. 
- 네이티브 메서드 스택은 자바 외 언어로 작성된 네이티브를 위한 메모리 영역입니다.

스레드가 생성되면 메서드 영역과 힙 영역을 공유하고 스택 영역, pc 레지스터, 네이티브 메서드 스택은 새롭게 생성됩니다.
</br></br>

#### Q. JAVA의 GC에 대해서 설명해주세요   
힙 영역은 eden, survivor1, survivor2, old, permanent로 구성됩니다. GC는 마이너 GC와 메이저 GC로 나뉘어집니다.  
  
Minor GC는 Young Gerneration영역에서 일어나는 GC입니다. Young Gerneration영역은 eden, survivor영역을 말합니다.
1.	최초에 객체는 eden영역에 생성됩니다. eden영역이 가득차면 첫 번째 GC가 발생합니다. 참조되고 있지 않은 객체는 제거하고, 참조되고있는 객체는 survivor1영역에 eden영역의 메모리를 그대로 복사합니다.
2.	eden영역이 다시 가득차면 eden영역에 객체와 survivor1영역에 생성된 객체중 참조되고있는 객체가 있는지 검사합니다. 참조되지 않는 객체는 제거하고 참조되는 객체는 survivor2영역에 복사함. 
3. survivor1과 survivor2로 객체의 이동을 반복하면서 살아있는 객체는 Age bit에 살아남은 횟수를 기록하고 age bit가 threshold값 이상이 되거나 survivor영역의 메모리가 부족해지면 old영역으로 이동합니다. 
survivor1과 survivor2를 이동하는 이유는 메모리 단편화를 피하기 위해서입니다. 이처럼 JVM에서 한 곳에 객체를 모으는 방식을 Compaction 이라고 합니다. 

Major GC는 Full GC로 Old 영역에서 일어나는 GC이다.
1.	Old영역에 데이터가 가득차면 GC를 실행한다. old영역에 모든 객체를 검사하여 참조되고 있는지 확인한다.
2.	참조되지 않는 객체들을 모아 한번에 제거한다. Minor GC에 비해 시간이 오래걸리고 작업중 GC스레드를 제외한 모든 스레드가 중단된다.
</br></br>

#### Q. JAVA언어의 장단점은 무엇인가요?
JVM에서 동작하므로 특정 운영체제에 종속되지않습니다.    
객체 지향언어로서 캡슐화, 상속, 다형성등을 지원합니다.   
Garbage Collector에 의해 사용하지 않는 메모리를 자동으로 수거합니다.   
멀티 스레딩이 가능합니다.    
바이트 코드로 컴파일 후 인터프리터 방식으로 동작하여 실행 속도가 느립니다.
checked exception은 예외 처리가 없다면 실행할 수 없습니다.
</br></br>

#### Q. JAVA의 접근 제어자에 대해 설명해주세요.
Private : 해당 클래스에서만 접근가능이 가능합니다.   
Package private : 같은 package에서만 접근 가능합니다.
Protected : 같은 package와 상속 받은 하위 클래스에서 접근 가능합니다. 
Public : 모든 클래스에서 접근이 가능합니다.  
</br></br>


#### Q. JAVA에서 static은 무엇인가요?
static은 객체의 생성 없이 접근이 가능하
접근 방식 : static으로 선언된 맴버와 메서드는 객체의 생성없이 접근할 수 있습니다. 반면, non-static으로 선언된 맴버와 메서드는 객체를 생성해야 접근할 수 있습니다.  
life cycle : static으로 선언된 맴버와 메서드는 클래스 로딩시 메서드 영역에 생성되고 프로그램이 종료될 때 소멸됩니다. 반면, non-static으로 선언된 맴버와 메서드는 객체를 생성할 때 만들어집니다.  
share : static으로 선언된 맴버는 동일 클래스로 객체를 생성하여 사용해도 같은 값을 공유합니다. 반면, non-static 맴버는 객체 생성시 새롭게 만들어지기 때문에 값을 공유하지 않습니다.
</br></br>

#### Q. static을 어떤 경우에 설정하면 좋을 까요?  
static은 클래스 로딩시 메소드 영역에 적재되고 프로그램 종료시 소멸하는 특징이 있습니다. static은 객체 생성 없이 사용할 수 있어 빠르지만 한번 만들어지면 GC에의해 제거되지 않기 때문에 너무 static을 남발하면 시스템 성능의저하를 가져올 수 있습니다. 또한, static 맴버는 값을 공유하는 특징이 있어 thread safe여부를 신경써야합니다. static으로 활용하면 좋은 상황은 객체의 생성 없이 접근 가능하게 유틸 클래스를 private 생성자로 구성하고 static 메서드를 사용하게 하는 방식이 있습니다. 예를 들어, java에서 Math클래스가 이런 방식을 사용합니다. 어떤 공통된 설정 값이 외부 요인에 의해 변경될 때, 그 설정 값을 사용하는 전체가 바뀌어야한다면 static 맴버를 사용하여 공통적으로 처리할 수 있습니다. 

</br></br>
