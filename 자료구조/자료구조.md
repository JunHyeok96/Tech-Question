# 자료구조

<details>
    <summary style="font-size : 20px;"><strong> Q. 배열과 연결리스트의 차이는 무엇인가요?</strong></summary></br>
    
**데이터 조회/수정**  
Array는 논리적인 저장순서와 물리적인 저장순서가 일치합니다. 배열은 인덱스를 사용해서 해당 원소에 접근할 수 있습니다. 찾고자하는 원소에 인덱스를 안다면 O(1)의 시간 복잡도로 접근이 가능합니다.

LinkedList는 자신의 앞과 뒤에 어떤 원소들이 연결되어있는지만 알고있습니다. 그렇기 때문에 원하는 원소를 찾기위해서는 순차적으로 탐색해야하며 O(n)의 시간 복잡도로 접근이 가능합니다. 

**데이터 추가/삭제**   
Array는 원하는 인덱스에 데이터를 추가하거나 삭제하고 싶다면 기존의 원소들을 이동해서 위치를 조정해야합니다. 따라서, 최악의 경우 시간 복잡도는 O(n)입니다. 더불어 배열은 고정 크기로서 배열의 크기 보다 많은 원소를 추가하는 상황이라면 배열의 크기를 늘리고 기존의 원소들을 새로운 배열에 옮기는 과정이 필요합니다. 이때 시간 복잡도는 O(n)이 소요됩니다.

LinkedList의 삽입과 삭제는 포인터만 수정하면되므로 기존의 원소들을 이동할 필요가 없습니다. 하지만 바로 원소에 접근할 수 없기때문에 원하는 원소에 도달할 때까지 탐색의 과정을 거쳐야합니다. 이런 경우 시간 복잡도는 O(n)입니다. 다만, head나 tail에 있는 원소에 대해 작업한다면 별도의 탐색이 필요하지 않아 O(1)의 시간 복잡도로 처리가 가능합니다.
</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. Stack과 Queue의 차이는 무엇인가요?</strong></summary></br>
    
 stack과 queue는 데이터가 출력되는 순서에 차이가 있습니다. stack은 LIFO구조로 늦게 들어가는 데이터가 먼저 나오는 방식입니다. 반면, queue는 FIFO방식으로 먼저 들어간 데이터가 먼저 나오는 방식으로 이뤄져있습니다. 
</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. 이진 트리, 포화 이진 트리, 완전 이진 트리는 무엇인가요?</strong></summary></br>
    
이진 트리 : 자식 노드가 최대 2개인 트리 구조  
포화 이진 트리 : 자식 노드가 2개인 트리 구조  
완전 이진 트리 : 마지막 레벨을 제외하고 모든 레벨이 가득 채워져 있고, 마지막 레벨의 노드는 왼쪽부터 채워져 나감  

</details></br>    
    
<details>
    <summary style="font-size : 20px;"><strong> Q. heap에 대해 설명해주세요.</strong></summary></br>
    
    
 힙은 우선 순위 큐를 위한 완전 이진 트리 구조로서 대표적으로 최대 힙과 최소 힙으로 나뉠 수 있습니다. 힙 구조는 정렬기준에 따라 값이 미리 정렬되면서 저장되므로 최대 값, 최소 값등 우선 순위를 기준으로 출력시 O(1)의 시간복잡도로 출력이 가능합니다. 데이터를 삽입하고 삭제하는 과정에서 정렬이 필요하며 O(logn)의 시간 복잡도가 소요됩니다.   

**데이터가 삽입되는 과정**
1. 새로운 데이터가 추가되면 마지막 노드에 삽입합니다.
2. 새로운 노드와 부모 노드를 비교하고 정렬 기준을 만족하면 서로 위치를 변경하며 위치를 조정합니다.

**데이터가 삭제되는 과정**
1. 우선 순위가 가장 높은 루트 노드가 삭제됩니다. 
2. 빈자리에는 마지막 노드를 옮깁니다.
3. 루트 노드가 된 마지막 노드를 자식 노드와 비교하여 정렬 기준을 만족한다면 서로 위치를 변경하며 위치를 조정합니다. 자식 노드중 우선 순위가 높은 노드와 값을 비교합니다.
    
</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. 이진 탐색 트리에 대해 설명해주세요.</strong></summary></br>
    
이진 탐색 트리는 이진 트리 기반의 탐색을 위한 자료 구조 입니다.   

**이진 탐색 트리는 다음의 조건을 만족해야합니다.**
1. 왼쪽 서브 트리는 해당 노드의 값보다 작다.
2. 오른쪽 서브 트리는 해당 노드의 값보다 크다.
3. 중복되는 값이 없다.
4. 서브트리는 이진 탐색 트리를 만족한다.

**이진 탐색 트리의 조회방식**
1. 조회하고자하는 값과 루트노드를 비교하며 시작합니다. 
2. 조회하고자하는 값이 노드의 값 보다 크다면 오른쪽, 작다면 왼쪽 서브트리로 이동합니다.
3. 이 과정을 반복하며 탐색을 진행합니다.

**데이터를 삽입하는 과정**
1. 삽입하고자하는 값을 우선 조회한다.
2. 최종 조회한 결과 트리안에 중복되는 값이 없다면 탐색이 종료되는 위치가 데이터가 삽입될 위치입니다.

**데이터를 삭제하는 시나리오는 3가지로 구분됩니다.**
1. 삭제하려는 노드가 단말 노드인 경우 메모리를 반납하면 쉽게 삭제할 수 있습니다.
2. 삭제하려는 노드가 하나의 자식 노드를 가지고 있는 경우 해당 노드의 부모 노드와 자식노드를 연결 시켜주면 됩니다.
3. 삭제하려는 노드가 두 개의 자식 노드를 가지고 있는 경우 왼쪽 서브트리의 최대 값 혹은 오른쪽 서브트리의 최소 값을 위치시킵니다. 이런 이유는 트리의 변동성을 최소화 하기 위해서입니다. 만약 다른 노드를 삭제하는 노드로 위치시킨다면 하위의 트리도 위치를 조정해야할 필요가 있습니다.

이진 탐색 트리의 시간 복잡도는 트리의 높이에 연관있습니다. 이상적으로 트리가 고르게 분포한 경우 시간복잡도는 logn으로 계산되지만 트리가 한쪽으로 치우친 경우 트리의 높이는 결국 선형 탐색과 다를바 없어지고 이때 시간 복잡도는 O(N)으로 계산 됩니다.  
    
</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. 그래프에 대해 설명해주세요 </strong></summary></br>
    
그래프는 node와 edge로 이뤄진 자료구조를 말합니다. 트리는 그래프의 일종으로 cycle이 불가능하며 노드간 방향성이 존재하지만 그래프는 cycle이 가능하고 노드간 방향성이 존재하지 않아도 상관없습니다. 연결된 객체간 관계를 표현할 때 유용하며 인접 행렬과 인접 리스트방식으로 구현할 수 있습니다.  

 **인접행렬**  
 인접 행렬은 노드의 수가 N인 경우 N*N의 형태로 행렬을 만들고 각 노드간 edge를 표현한 방식입니다. 두 노드간 연결된 정보를 확인할 떄 O(1)의 시간 복잡도로 접근이 가능하지만 edge의 수와는 무관하게 항상 N^2의 메모리 공간이 필요하고 인접행렬을 만드는 과정에서도 N^2의 시간복잡도가 소요됩니다.  
 
 **인접 리스트**  
 인접 리스트는 노드와 노드가 edge로 연결된 상태를 리스트로 만들어 표현하는 방식입니다. 인접 리스트는 edge의 수가 적은 sparse한 구조일 수록 메모리 공간에서 효율적이지만 두 노드간 연결 여부를 확인하는 과정이 인접행렬보다는 시간이 더 걸립니다.
</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. DFS, BFS에 대해 설명해주세요.</strong></summary></br>
    
DFS는 깊이 우선 탐색 방식으로서 갈수있는 노드가 확인되면 최대한 가능한 곳까지 탐색하며 더이상 탐색이 불가능한 노드에 도달했을 때 이전 노드로 이동해가면서 그래프를 탐색하는 방식입니다. 보통 재귀구조나 stack을 통해 구현됩니다.  

BFS는 넓이 우선 탐색 방식으로서 접근한 노드에 인접하여 연결된 노드를 차례대로 탐색하는 방식 입니다. 즉, 지금 노드에서 이동할 수 있는 인접 노드를 순차적으로 탐색합니다. queue를 사용해서 구현가능합니다.    

두 가지 방식 모두 그래프내 모든 노드를 탐색한다는 점에서 시간 복잡도가 같습니다. 인접 행렬을 사용하면 O(V^2)의 시간 복잡도가 소요되고 인접 리스트를 사용하면 O(V+E)의 시간 복잡도가 소요됩니다.

</details></br>

<details>
    <summary style="font-size : 20px;"><strong> Q. Hash Table에 대해 설명해주세요.</strong></summary></br>
    
Hash Table은 Key, Value형식의 데이터를 저장하는 자료 구조입니다. 해시 함수를 사용해서 key값을 해싱하고 나머지 연산을 통해 해싱된 값을 인덱스로 사용합니다. 따라서 key를 통한 값을 조회할 때 시간 복잡도는 O(1)이 소요됩니다. 하지만 Key값의 형태는 무한한데 해싱된 인덱스의 형태는 제한되어있습니다. 그러므로 서로 다른 key에 대해 해싱한 결과가 중복되는 해시 충돌이 발생할 수 있습니다. 이를 해결하기 위해서는 separate chaining 방식과 open addressing 방식을 사용합니다.

separate chaining은 해시 값의 충돌이 발생했을 때 연결리스트나 트리 형태로 엔트리에 값을 이어 붙이는 방식입니다. 별도의 인덱스를 사용하지않아 공간에 대한 제약이 적으나 최악의 경우 O(n)의 시간 복잡도가 발생할 수 있습니다.

open addressing은 해시 값의 충돌이 발생했을 때 이후 index의 빈 버킷을 찾아 저장하는 방식입니다. 삭제의 경우 separate chaining방식보다 좀 더 복잡합니다. 해시 충돌이 일어나 해당 index이후를 탐색해서 빈 버킷에 저장한 경우를 가정해보겠습니다. 만약, 충돌이 발생한 index에 값을 삭제하면 해당 index는 비어있게되고 이전에 충돌로 인해 다음 index에 저장된 값을 찾지 못하는 문제가 발생할 수 있습니다. 이런 경우 삭제 후 더미 노드를 넣어 충돌을 유지하여 문제를 해결할 수 있습니다. 하지만 더미 노드가 많아져 탐색 성능이 저하되면 새로운 배열을 만들어야합니다. open addressing은 선형적으로 비어있는 버킷을 탐색하는 Linear Probing, 제곱으로 탐색하는 Quadratic Probing, 해싱된 값을 한번 더 해싱하는 Double Hashing방식이 있습니다.



</details></br>
