# 자료구조

#### Q. 배열과 연결리스트의 차이는 무엇인가요?
**데이터 조회/수정**  
Array는 논리적인 저장순서와 물리적인 저장순서가 일치합니다. 따라서 인덱스를 사용해서 해당 원소에 접근할 수 있습니다. 찾고자하는 원소에 인덱스를 안다면 Big-O(1)의 시간 복잡도로 접근이 가능합니다.

LinkedList는 인덱스가 존재하지 않습니다. 자신의 앞과 뒤에 어떤 원소들이 연결되어있는지만 알고있습니다. 그렇기 때문에 원하는 원소를 찾기위해서는 순차적으로 탐색해야하며 Big-O(n)의 시간 복잡도로 접근이 가능합니다. 

**데이터 추가/삭제**  
Array는 원하는 인덱스에 데이터를 추가하거나 삭제하고 싶다면 해당 인덱스에 접근해 작업을 해야하고 기존의 원소들을 시프트 해서 빈 공간이 발생하지 않도록 위치를 조정해야합니다. 최악의 경우 시간 복잡도는 Big-O(n)입니다.
Array는 최초에 고정 크기의 배열로서 만들어집니다. 만약, 배열의 크기를 초과하여 데이터를 저장해야하는 경우 기존의 배열을 새로운 배열로 복사하는 과정이 필요하고 이런 경우 Big-O(n)의 시간 복잡도가 소요됩니다. 

LinkedList는 삽입이나 삭제의 경우 포인터만 수정하여 작업할 수 있습니다 하지만 바로 원소에 접근할 수 없기때문에 원하는 원소에 도달할 때까지 탐색의 과정을 거쳐야한다. 이런 경우 시간 복잡도는 Big-O(n)이다. 다만, head나 tail에 있는 원소를 조작하는경우
 Big-O(1)의 시간 복잡도로 처리가 가능합니다.
 

 </br> </br>

#### Q. Stack과 Queue의 차이는 무엇인가요?
stack과 queue는 데이터가 출력되는 순서에 차이가 있습니다. stack은 LIFO구조로 늦게 들어가는 데이터가 먼저 나오는 방식입니다. 반면, queue는 FIFO방식으로 먼저 들어간 데이터가 먼저 나오는 방식으로 이뤄져있습니다. 
 </br> </br>

#### Q. heap에 대해 설명해주세요.
heap은 완전 이진 트리 구조입니다. 힙은 우선 순위 큐를 위한 자료구조로서 최대 힙과 최소 힙으로 나뉠 수 있습니다. 최대 힙은 자신의 노드가 자식 노드보다 값이 크거나 같고 최소 힙은 자신의 노드가 자식 노드보가 값이 작거나 같습니다. 힙 구조는 정렬기준에 따라 값이 미리 정렬되면서 저장되므로 최대 값, 최소 값을 출력시 Big-O(1)의 시간복잡도로 출력이 가능합니다. 다만 데이터를 삽입하고 삭제하는 과정에서 정렬이 필요하며 Big-O(logn)의 시간 복잡도가 소요됩니다. 이진 탐색 트리에서는 중복된 값을 허용하지 않으나 힙은 중복된 값을 허용합니다.

**데이터가 삽입되는 과정**
1. 새로운 데이터가 추가되면 마지막 노드에 삽입합니다.
2. 새로운 노드와 부모 노드를 비교하고 정렬 기준을 만족하면 서로 위치를 변경하며 위치를 조정합니다.

**데이터가 삭제되는 과정**
1. 최대 값 혹은 최소 값인 루트 노드가 삭제됩니다. 
2. 빈자리에는 마지막 노드를 옮깁니다.
3. 루트 노드가 된 마지막 노드를 자식 노드와 비교하여 정렬 기준을 만족한다면 서로 위치를 변경하며 위치를 조정합니다. 최대 힙이라면 자식 노드중 더 큰 값과 비교하고 최소 힙이라면 더 작은 노드와 비교합니다.
 </br> </br>


#### Q. 이진 탐색 트리에 대해 설명해주세요.
이진 탐색 트리는 이진 트리 기반의 탐색을 위한 자료 구조 입니다.   
**이진 탐색 트리는 다음의 조건을 만족해야합니다.**
1. 왼쪽 서브 트리는 해당 노드의 값보다 작다.
2. 오른쪽 서브 트리는 해당 노드의 값보다 크다.
3. 중복되는 값이 없다.
4. 서브트리는 이진 탐색 트리를 만족한다.

**이진 탐색 트리의 조회방식**
1. 조회하고자하는 값과 최초에 루트노드와 비교하며 시작합니다. 
2. 조회하고자하는 값보다 노드의 값이 크다면 오른쪽, 작다면 왼쪽 서브트리로 이동합니다.
3. 찾고자하는 값이 해당 노드보다 큰지, 작은지 비교해가며 반복하여 이동합니다.   

**데이터를 삽입하는 과정**
1. 삽입하고자하는 값을 우선 조회한다.
2. 최종 조회한 결과 트리안에 중복되는 값이 없다면 마지막 노드에서 조회한 값은 null로 확인됩니다. 이 위치에 데이터를 삽입합니다.

**데이터를 삭제하는 시나리오는 3가지로 구분됩니다.**
1. 삭제하려는 노드가 단말 노드인 경우 그냥 메모리를 반납하면 쉽게 삭제할 수 있습니다.
2. 삭제하려는 노드가 하나의 자식 노드를 가지고 있는 경우 해당 노드의 부모 노드와 자식노드를 연결 시켜주면 됩니다.
3. 삭제하려는 노드가 두 개의 자식 노드를 가지고 있는 경우 왼쪽 서브트리의 최대 값 혹은 오른쪽 서브트리의 최소 값을 위치시킵니다. 이런 이유는 트리의 변동성을 최소화 하기 위해서입니다. 만약 다른 노드를 삭제하는 노드로 위치시킨다면 하위의 트리도 위치를 조정해야할 필요가 있습니다.

이진 탐색 트리의 시간 복잡도는 트리의 높이에 연관있습니다. 트리가 고르게 분포한 경우 시간복잡도는 logn으로 계산되지만 트리가 한쪽으로 치우친 경우 트리의 높이는 결국 선형 탐색과 다를바 없어지고 이때 시간 복잡도는 Big-O(N)으로 계산 됩니다.  
 </br> </br>
